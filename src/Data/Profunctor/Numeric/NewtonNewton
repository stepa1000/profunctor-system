{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE Arrows #-}

module Data.Profunctor.Numeric.FAD where

import Control.Profunctor.Postlude

--import Data.Profunctor.System.Body

--import Data.HashMap.Lazy
--import Data.Hashable

import Control.Lens

import Control.Comonad.Trans.Coiter
import Control.Comonad.Env
import Data.Foldable (toList, find)
import Prelude
import Prelude.Compat ()

data Function = Function {
 -- Function to find zeroes of
 function   :: Double -> Double,
 -- Derivative of the function
 derivative :: Double -> Double
}

data Result = Result {
 -- Estimated zero of the function
 value  :: Double,
 -- Estimated distance to the actual zero
 xerror :: Double,
 -- How far is value from being an actual zero; that is,
 -- the difference between @0@ and @f value@
 ferror :: Double
} deriving (Show)

data Outlook = Outlook { result :: Result,
                        -- Whether the result improves in future steps
                        progress :: Bool } deriving (Show)

type Solution a = CoiterT (Env Function) a

type Problem = Env Function Double

newton :: Problem -> Solution Double
newton = unfold (\wd ->
                   let  f  = asks function wd in
                   let df  = asks derivative wd in
                   let  x  = extract wd in
                   x - f x / df x)
